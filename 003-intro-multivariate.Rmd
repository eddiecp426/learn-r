---
title: "Introduction to Multivariate Statistics in R"
author: "Jeff Oliver"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    css: stylesheets/markdown-styles.css
---

## TODO:
1. ~~Add instructions for downloading data then exporting as CSV file~~
2. Break apart PCA code in stepwise fashion
3. ~~Provide rationale for why PCA~~
4. ~~Add (advanced) code for detecting the number of clusters~~
5. ~~Provide spreadsheet software info (Excel, LibreOffice) on 000-setup-instructions page~~
6. Add DFA section
    + Add explanation of posterior probabilities (make a table?)
    + Break apart graphics section

##See: 
###PCA:

+ http://www.statmethods.net/advstats/factor.html
+ https://www.r-bloggers.com/computing-and-visualizing-pca-in-r/
+ [Why PCA? (or "how to explain PCA to your grandmother")](http://stats.stackexchange.com/questions/2691/making-sense-of-principal-component-analysis-eigenvectors-eigenvalues)
+ [Principal Components Regression](https://www.r-bloggers.com/performing-principal-components-regression-pcr-in-r/)

An introduction to using the R statistics package and the RStudio interface for multivariate statistics.

####Learning objectives
1. Prepare data in spreadsheet program (e.g. Excel, LibreOffice Calc) for export to R
2. Read data from files into R
3. Run Principal Components Analysis (PCA) and graphically display results
4. Run K-means clustering analysis

##Setup
###Workspace organization
First we need to setup our development environment. We need to create two folders: 'data' will store the data we will be analyzing, and 'output' will store the results of our analyses.
```{r, eval = FALSE}
dir.create(path = "data")
dir.create(path = "output")
```

###Preparing data in a format R can read
+ Download data file from [https://jcoliver.github.io/learn-r/data/otter-mandible-data.xlsx](https://jcoliver.github.io/learn-r/data/otter-mandible-data.xlsx) or [http://tinyurl.otter-data](http://tinyurl.otter-data) (the latter just re-directs to the former). These data are a subset of those used in a study on skull morphology and diet specialization in otters [doi: 10.1371/journal.pone.0143236](http://dx.doi.org/10.1371/journal.pone.0143236).
+ Open this file, otter-mandible-data.xlsx, in spreadsheet program like Microsoft Excel<sup>&reg;</sup> or LibreOffice Calc.
+ Save a copy of the file as a CSV (comma-separated values) file named 'otter-mandible-data.csv' in the data folder you created above:
    + In MS Excel<sup>&reg;</sup>, select File > Save As... and in the dialog that appears, select CSV from the type dropdown menu.
    + In LibreOffice Calc, select File > Save As... and in the dialog that appears, select Text CSV (.csv) in the Format dropdown in the lower-right portion of the dialog.

###Reading data into R
```{r}
otter <- read.csv(file = "data/otter-mandible-data.csv", header = TRUE)
```
  
Missing data can cause problems in downstream analyses, so we will just remove any rows that have missing data. Here we replace the original data object `otter` with one in which there are no missing values. Note, this _does not_ alter the data in the original file we read into R; it only alters the data object `otter` currently in R's memory.
```{r}
otter <- na.omit(otter)
```

##PCA
+ Do pca
+ point out
    + summary for the proportion of variance (remember if you want to show how this is calculated, the standard deviation has to be squared to get variance)
    + loadings for what points along an axis actually mean
+ do call to biplot (ugly)?
+ do plot from fit$x
  + make plot nicer

Why PCA? Very briefly, Principal Components Analysis is a way of re-describing the variation observed in your data. It serves as a means of reducing the dimensionality of data (i.e. reducing the number of predictor variables) and is often used for exploratory analyses. The full rationale and mathematically underpinnings are waaaaaaaay beyond the scope of this lesson, and other resources already do a fairly good job of explaining PCA. If you want a few perspectives for a relatively novice audience, check out this [Why PCA? (or "how to explain PCA to your grandmother")](http://stats.stackexchange.com/questions/2691/making-sense-of-principal-component-analysis-eigenvectors-eigenvalues) thread at Stack Overflow. If you are more inclined to print media, I highly recommend B.F.J. Manly's _Multivariate Statistical Methods: A primer_ [*TODO: REF*], which provides an excellent introduction to a variety of multivariate statistic topics.
  
So, on to the code:
```{r}
pca.fit <- prcomp(x = otter[, -1], scale. = TRUE)
```
That's PCA. We pass the data to the `x` parameter, skipping the first column `[, -1]` because that has the name of the species the data came from (and is not something we can analyze with the PCA). We also set the `scale.` parameter to `TRUE` because we want to transform the data so each column has a mean of zero and a variance of one.
  
To look at the results, we use the `summary` command and assign the output to a variable.
```{r}
pca.summary <- summary(pca.fit)
ls(pca.summary) # Lists the objects produced by summary
```

We are interested to know (1) what are the important factors that emerge from the PCA (i.e. which ones explain a lot of variation) and (2) what do these factors actually say about the variation observed in our data. For (1), look at the `importance` object in the summary:
```{r}
pca.summary$importance
```
The second row, `Proportion of Variance`, shows how much variation in the data is described by each component; notice that the first component, PC1, explains the most variance, `r round(pca.summary$sdev[1]^2/sum(pca.summary$sdev^2), 4)`, or `r round(pca.summary$sdev[1]^2/sum(pca.summary$sdev^2) * 100, 2)`% of the total variance, the second component explains the second most variance (`r round(pca.summary$sdev[2]^2/sum(pca.summary$sdev^2) * 100, 2)`%), and so on, with each successive component explaining a lower proportion of the total variance. For the remainder of the lesson, we will focus on the first two principal components, PC1 and PC2, which together explain `r round((pca.summary$sdev[1]^2 + pca.summary$sdev[2]^2)/sum(pca.summary$sdev^2) * 100, 2)`% of the observed variation in the skull measurements.
  
But what about that variation? What are the principal components actually explaining? To address this (point 2 from above), we need to look at the loadings of the PCA. The `rotation` object from the summary call has the information we are interested in. Focus on the values in the PC1 column:
```{r}
pca.summary$rotation
```

```{r echo = FALSE}
# Crude, but should be fine
direction <- "positive"
if (sum(pca.summary$rotation) < 0) {
  direction <- "negative" 
}
```
Looking at the signs of the loadings, we see they are all the same (`r direction`), thus this first component, explaining most of the variation in the measurements, is really just reflecting variation in size. That is, since all the loadings have the same sign, large values for one skull measurement generally coincide with large values for other skull measurements for this first component.
  
The second principal component is a little more interesting. Two of the variables, mandibular ramus width and outlever at carnassial don't contribute much to the component (the magnitudes of their respective loadings (.173 and .031) are small compared to the other four skull measurements). The remaining four indicate a shape difference, with one pair of variables having positive loadings and one pair having negative loadings. This interpretation of the second principal component would benefit greatly from a graphical representation.
  
Plotting the results of a PCA can be done using a simple call to the `biplot` function:
```{r}
biplot(x = pca.fit)
```

But that figure really leaves much to be desired, and gets messier with larger sample sizes and more variables. If you want to find out more about how that figure is produced, look at the documentation for `biplot` (`?biplot`).

Instead, we can plot the scores of the first two principal components using the standard `plot` command, using the scores that are stored in the `x` object of `pca.fit`:
```{r}
plot(x = pca.fit$x[, 1],
     y = pca.fit$x[, 2],
     xlab = "PC 1",
     ylab = "PC 2")
```

Well, maybe that plot isn't so useful either. It does help a bit if we color the points by species, though.
```{r}
# Pull out the unique values in the 'species' column
species <- unique(otter$species)

# Set up a vector of colors for the *legend*
legend.cols <- c("black", "forestgreen", "cadetblue", "darkred") 

# Set up a vector of colors for the actual *plot*, based on values in the 
# 'species' column and the legend colors vector. This vector has one element 
# corresponding to each row of the otter data frame. 
pt.cols <- rep(x = legend.cols[1], length = nrow(otter))
pt.cols[otter$species == species[2]] <- legend.cols[2]
pt.cols[otter$species == species[3]] <- legend.cols[3]
pt.cols[otter$species == species[4]] <- legend.cols[4]
plot(x = pca.fit$x[, 1],
     y = pca.fit$x[, 2],
     xlab = "PC 1",
     ylab = "PC 2",
     pch = 19,
     col = pt.cols)
legend("bottomleft", legend = species, pch = 19, col = legend.cols, cex = 0.8)
```

Ah, now this is a little more interesting. Note the first principal component scores along the x-axis, and there is actually pretty clear separation among some of species. As mentioned above, this principal component is really an index of size, which we can visualize by looking at the actual skull measurements across the four species. First note the distribution of the four species along the x-axis: _A. cinerea_ has the lowest values, _E. lutris_ and _P. brasiliensis_ have the highest values, and _L. canadensis_ has values in the middle. We can use `boxplot` to show the distributions of each measurement for each species:

```{r}
# Set-up a multi-panel graph (2 rows, 3 columns), filling row by row
par(mfrow = c(2, 3), las = 2) 

# Plot each of the six measurements in a different plot
boxplot(formula = mandibular.ramus.width ~ species, data = otter)
boxplot(formula = mandibular.ramus.height ~ species, data = otter)
boxplot(formula = moment.arm.temporalis ~ species, data = otter)
boxplot(formula = outlever.at.carnassial ~ species, data = otter)
boxplot(formula = moment.arm.masseter ~ species, data = otter)
boxplot(formula = jaw.length ~ species, data = otter)

# Restore graphing defaults
par(mfrow = c(1, 1), las = 0)
```

Looking at these boxplots, we see that indeed, for all six measurements, _A. cinerea_ has the lowest values, _E. lutris_ and _P. brasiliensis_ have the highest values, and _L. canadensis_ has values in the middle.
  

Remember that second principal component, PC2, on the y-axis of our scatterplot: 

```{r, echo = FALSE}
plot(x = pca.fit$x[, 1],
     y = pca.fit$x[, 2],
     xlab = "PC 1",
     ylab = "PC 2",
     pch = 19,
     col = pt.cols)
legend("bottomleft", legend = species, pch = 19, col = legend.cols, cex = 0.8)
```

And the loadings for the first two components are:
```{r, echo = FALSE}
pca.summary$rotation[, 1:2]
```

In this second principal component, as mentioned before, mandibular ramus width and outlever at carnassial don't contribute much to the component [the magnitudes of their respective loadings (.173 and .031) are small compared to the other four skull measurements]. The remaining four loadings indicate a shape difference, with one pair of variables having positive loadings and one pair having negative loadings. This component describes variation in the four variables: samples with high values of jaw length and moment arm temporalis have low values of mandibular ramus height and moment arm masseter and vice versa. You can confirm this looking again at a boxplot for these values, focusing only on those four variables of interest for the two species that are differentiated along PC2, _E. lutris_ and _P. brasiliensis_:

```{r}
# Set-up a multi-panel graph (1 row, 4 columns), filling row by row
par(mfrow = c(1, 4), las = 2) 

# Plot each of the six measurements in a different plot
boxplot(formula = mandibular.ramus.height ~ species, data = otter, main = "MRH", cex = 0.8)
boxplot(formula = moment.arm.temporalis ~ species, data = otter, main = "MAT", cex = 0.8)
boxplot(formula = moment.arm.masseter ~ species, data = otter, main = "MAM", cex = 0.8)
boxplot(formula = jaw.length ~ species, data = otter, main = "JL", cex = 0.8)

# Restore graphing defaults
par(mfrow = c(1, 1), las = 0)
```
Indeed, where _E. lutris_ has higher values of mandibular ramus height ("MRH") and moment arm masseter ("MAM") than _P. brasiliensis_, the reverse is true for moment arm temporalis ("MAT") and jaw length("JL"). The second principal component is thus describing variation in relative sizes of these four different measurements.

Our script for performing Principal Components Analysis and graphing the first two components should look like this:
```{r, eval = FALSE}
# PCA on otter jaw measurements
# Jeff Oliver
# jcoliver@email.arizona.edu
# 2016-11-18

# Read in data
otter <- read.csv(file = "data/otter-mandible-data.csv", header = TRUE)

# Drop rows with NA
otter <- na.omit(otter)

# Run PCA
pca.fit <- prcomp(x = otter[, -1], scale. = TRUE)
pca.summary <- summary(pca.fit)

# Plotting results
# Pull out the unique values in the 'species' column for legend
species <- unique(otter$species)

# Set up a vector of colors for the *legend*
legend.cols <- c("black", "forestgreen", "cadetblue", "darkred") 

# Set up a vector of colors for the actual *plot*, based on values in the 
# 'species' column and the legend colors vector. This vector has one element 
# corresponding to each row of the otter data frame. 
pt.cols <- rep(x = legend.cols[1], length = nrow(otter))
pt.cols[otter$species == species[2]] <- legend.cols[2]
pt.cols[otter$species == species[3]] <- legend.cols[3]
pt.cols[otter$species == species[4]] <- legend.cols[4]

# Plot the first two components
plot(x = pca.fit$x[, 1],
     y = pca.fit$x[, 2],
     xlab = "PC 1",
     ylab = "PC 2",
     pch = 19,
     col = pt.cols)
legend("bottomleft", legend = species, pch = 19, col = legend.cols, cex = 0.8)
```

***

##Discriminant Function Analysis
Principal Components Analysis is useful to describe variation, especially when groups of samples are not known _a priori_. However, when the groups _are_ known, one can use Discriminant Function Analysis, DFA, to see if the these groups can be differentiated based on a suite of variables. We will use the same otter data to see if we can differentiate among the four species based on the jaw measurements.
```{r}
# Read in data
otter <- read.csv(file = "data/otter-mandible-data.csv", header = TRUE)

# Drop rows with NA
otter <- na.omit(otter)
```
  
To run a DFA, we use a function in the `MASS` library, an additional package of R functions. To load a package for use in R, we use the `library` function and include the name of the package (see below if you want to learn more about [installing packages](#installing-r-packages)):
```{r}
library("MASS")
```

And we run DFA with a call to `lda` indicating which column contains our _a priori_ groups in via the `formula` parameter. In this case, we pass `formula = species ~ .`, which means `species` contains our grouping variable and the '.' means we want to use all remaining variables in the `otter` data frame as predictors in the analysis:
```{r}
lda.fit <- lda(formula = species ~ ., 
               data = otter, 
               prior = c(1,1,1,1)/4, 
               CV = TRUE)
```
We also indicate that assignment to each species is equally likely (25%) by setting the prior probabilities for group membership through the `prior` parameter. 
  
Finally, by setting `CV = TRUE`, R will perform cross-validation on the model and provide posterior probabilities of group membership in the `posterior` object returned by `lda`. Look at the first few rows of the posterior probabilities:
```{r}
head(lda.fit$posterior)
```
The `lda.fit$posterior` data frame holds the posterior probability of assignment to each of the four species for each row of data in the original `otter` data. The first row indicates that 

```{r}
posteriors <- t(lda.fit$posterior)
```


plottingdfa
```{r}
legend.cols <- c("black", "forestgreen", "cadetblue", "darkred") 

tick.pos <- c(0, 
              nrow(otter) - match(levels(otter$species)[1], rev(otter$species)) + 1, # last occurrence of first species
              nrow(otter) - match(levels(otter$species)[2], rev(otter$species)) + 1, # last occurrence of second species
              nrow(otter) - match(levels(otter$species)[3], rev(otter$species)) + 1, # last occurrence of third species
              nrow(otter) - match(levels(otter$species)[4], rev(otter$species)) + 1)# last occurrence of fourth species)

label.pos <- c(floor((tick.pos[2] - tick.pos[1]) / 2),
               floor((tick.pos[3] - tick.pos[2]) / 2 + tick.pos[2]),
               floor((tick.pos[4] - tick.pos[3]) / 2 + tick.pos[3]),
               floor((tick.pos[5] - tick.pos[4]) / 2 + tick.pos[4]))

mar.default <- c(5, 4, 4, 2) + 1 # from par documentation
par(mar = mar.default + c(2, 0, 0, 0)) 

barplot(posteriors,
        ylab = "Posterior Probability",
        space = 0,
        border = NA,
        xaxt = 'n',
        xlim = c(0, ncol(posteriors) + 45),
        col = legend.cols,
        legend.text = levels(otter$species),
        args.legend = list(cex = 0.7, x = ncol(posteriors) + 55, y = 0.6, xpd = TRUE))
axis(side = 1, at = tick.pos, labels = FALSE) # tick marks
axis(side = 1, at = label.pos, labels = levels(otter$species), tick = FALSE, par(las = 2, cex = 0.8))

par(mar = mar.default)
```

***

###References

See: [Bibliographies in RStudio](http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html)

***

###Installing R packages
Note that if a package is not installed on your machine, a call to `library` will throw an error, indicating the package has to be installed first. For example, if we were to load a package called `mustelid` without installing it first:
```{r error = TRUE}
library("mustelid")
```
So how do I install packages? you ask. With `install.packages`:
```{r eval = FALSE}
install.packages("mustelid")
library("mustelid")
```


Questions?  e-mail me at <a href="mailto:jcoliver@email.arizona.edu">jcoliver@email.arizona.edu</a>.